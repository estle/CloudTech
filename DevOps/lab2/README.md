# Описание лабораторной работы

### Лабораторная 2

Написать два Dockerfile – плохой и хороший. Плохой должен запускаться и работать корректно, но в нём должно быть не менее 3 “bad practices”. В хорошем Dockerfile они должны быть исправлены. В Readme описать все плохие практики из кода Dockerfile и почему они плохие, как они были исправлены в хорошем  Dockerfile, а также две плохие практики по использованию этого контейнера

### Лабораторная 2 со звёздочкой

Запустить Kubernetes кластер (подойдёт minikube или kind). Запустить ваши контейнеры внутри этого кластера, при этом всё должно быть описано кодом. В минимальном варианте должен быть deployment и service. Приложение, работающее внутри контейнера внутри кластера должно открываться локально у вас в браузере.

# Выполнение лабораторных работ

## Лабораторная 2

### Flask

Для выполения лабораторной работы будет использоваться небольшая веб-страница, реализованная с помощью Flask в Python 3.

### Bad practices in Dockerfile

```badDockerfile
# 1 bad practice
FROM python

# 2 bad practice
COPY . /app

WORKDIR /app

RUN pip install -r requirements.txt

# 3 bad practice
CMD ["python3", "app.py"]
```

Разбор плохих практик, применяющихся в _Dockerfile_:
1. Использование ```FROM python``` в _Dockerfile_ считается плохой практикой, так как при этом всегда используется latest версия Python. Это может привести к проблемам совместимости и непредсказуемому поведению приложения. Кроме того, базовый образ python содержит лишние зависимости и будет более тяжелым по размеру, что может замедлить процесс сборки и запуска контейнера.
2. Копирование всего проекта ```COPY . /app``` до установки всех зависимостей замедляет процесс сборки контейнера. Каждый шаг в Dockerfile создает новый “слой”, который, по сути, представляет собой дифф изменений файловой системы с момента последнего шага. Каждый раз, когда мы изменяем файл в проекте, Docker будет перестраивать все последующие слои образа, даже если изменения произошли только в одном файле.
3. Использование только CMD (без определения ENTRYPOINT) позваоляет легко переопределять исполняемый файл. Так можно добавить желаемую команду в конце строки docker run.


### Good practices in Dockerfile

 ```goodDockerfile
FROM python:3.11-alpine

COPY ./requirements.txt /app/requirements.txt

WORKDIR /app

RUN pip install -r requirements.txt

COPY . /app

ENTRYPOINT [ "python3" ]

CMD ["app.py" ]
```

Разбор хороших практик на замену плохим:
1. Использование конкретной версии, например ```FROM python:3.11-alpine```, позволяет точно определить версию Python и уменьшить размер образа за счет использования минимального базового образа Alpine Linux. Такой подход считается более надежным и эффективным при создании контейнеров.
2. Рекомендуется использовать многоэтапную сборку (multi-stage build), когда в первом этапе копируются только необходимые для установки зависимостей файлы ```COPY ./requirements.txt```, а во втором этапе уже копируются файлы приложения ```COPY . /app```. Это позволяет уменьшить размер образа и ускорить процесс сборки.
3. При использовании ```ENTRYPOINT ["python3"]``` пользователю достаточно указать только имя файла при запуске контейнера, что удобнее, понятнее и менее уязвимо.

### Этапы выполнения

1. Сборка Docker образа _badapp_ с использованием __плохих__ практик в Dockerfile. Время сборки: 3.8s <img width="886" alt="Снимок экрана 2023-11-01 в 00 28 36" src="https://github.com/estle/CloudTech/assets/52665965/af970302-6433-4ac0-ba4d-2e0d052da637">

2. Сборка Docker образа _goodapp_ с использованием __хороших__ практик в Dockerfile. Время сборки: 1.9s <img width="884" alt="Снимок экрана 2023-11-01 в 00 29 36" src="https://github.com/estle/CloudTech/assets/52665965/2c3b9ba1-0249-4c40-ab00-1857d65acb4d">

3. Вес образа _badapp_ на диске 1.03 GB, что больше чем в 10 раз больше веса образа _goodapp_ на диске 74.38 MB. Причиной тому является значительный вес родительского образа с большим числом ненужных зависимостей. <img width="967" alt="Снимок экрана 2023-11-01 в 00 29 55" src="https://github.com/estle/CloudTech/assets/52665965/c2f9fece-dc50-438e-bf46-185fc765077b">

4. Результат работы контейнера вне зависимости от образа – корректно работающее веб-приложение на Flask в локальной сети <img width="1034" alt="Снимок экрана 2023-11-01 в 00 31 23" src="https://github.com/estle/CloudTech/assets/52665965/6eac9c33-fbed-4e7e-bfc4-f4cf20df08e8">

### Две плохие практики по использованию контейнера

1. Использование Docker контейнера для запуска приложения на Flask может быть необоснованным, если приложение не требует масштабирования или изоляции от других приложений. В таком случае, использование контейнера может быть излишним и увеличивать сложность настройки и поддержки системы.

2. Хранение ключа Secret_Key конфига приложения внутри Docker контейнера является плохой практикой, так как это может привести к утечке конфиденциальных данных в случае компрометации контейнера.
